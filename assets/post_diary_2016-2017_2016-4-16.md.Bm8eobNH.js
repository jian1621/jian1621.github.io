import{_ as e,c as a,o as i,ag as r}from "./chunks/framework.BVgKs9HZ.js";const d=JSON.parse('{"title":"Android开发的基础知识总结2","description":"主要介绍activity的基础知识。","frontmatter":{"title":"Android开发的基础知识总结2","date":"2016-04-25T20:46:50.000Z","tags":["学习"],"description":"主要介绍activity的基础知识。"},"headers":[],"relativePath":"post/diary/2016-2017/2016-4-16.md","filePath":"post/diary/2016-2017/2016-4-16.md"}'),l={name:"post/diary/2016-2017/2016-4-16.md"};function n(o, t, c, s, g, h){return i(),a("div",null,t[0]||(t[0]=[r('<blockquote><p>参考文章:</p></blockquote><ul><li>郭神--第一行代码</li><li><a href="http://www.cnblogs.com/lwbqqyumidi/p/3769113.html" target="_blank" rel="noreferrer">Activity的生命周期--cornblog</a></li><li><a href="http://www.cnblogs.com/kofi1122/archive/2011/04/10/2011772.html" target="_blank" rel="noreferrer">Activity生命周期之我见--kofi1122</a></li><li><a href="http://blog.csdn.net/android_tutor/article/details/5772285" target="_blank" rel="noreferrer">两分钟彻底让你明白Android Activity生命周期(图文)--Android_Tutor</a></li><li><a href="http://blog.csdn.net/liuhe688/article/details/6733407" target="_blank" rel="noreferrer">总结篇之activity--scott</a></li></ul><h3 id="返回栈" tabindex="-1">返回栈 <a class="header-anchor" href="#返回栈" aria-label="Permalink to &quot;返回栈&quot;">​</a></h3><p>使用任务栈来管理活动，当back键或finish()方法销毁一个活动时，处于栈顶的栈会出栈。前一个活动会处于栈顶。系统总会显示在栈顶的活动。</p><h4 id="活动状态" tabindex="-1">活动状态 <a class="header-anchor" href="#活动状态" aria-label="Permalink to &quot;活动状态&quot;">​</a></h4><ul><li>运行状态：即在栈顶的活动。</li><li>暂停状态：一个活动不再处于栈顶，但可见时，活动进入暂停状态。（类似模态对话框，即一个小activity是当前活动，但不能完全覆盖背景activity,背景activity依旧可见。这样背景activity就进入暂停状态。）</li><li>停止状态：一个活动不是在栈顶位置，而且完全不可见，其进入停止状态。当内存非常紧缺的时候，这些活动会被回收，需要非常注意其可靠性。</li><li>销毁状态：从返回栈中出栈后，该活动就成为了销毁状态。</li></ul><h3 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h3><ul><li>onCreate(): 在活动第一次创建的时候被调用，完成一些数据的初始化工作。</li><li>OnStart(): 在活动由不可见变为可见的时候调用。</li><li>OnResume(): 活动准备好与用户交互时调用，活动一定处于栈顶，而且为运行状态。</li><li>OnPause(): 在准备启动或恢复另一个活动时调用，消耗时间要尽量少，以免影响另一个活动的运行。</li><li>OnStop(): 活动完全不可见时调用，与OnPause()区别在于如果启动的一个新活动是对话框式的活动，则执行OnPause()而非OnStop();</li><li>OnDestroy(): 活动被销毁之前调用，调用之后，活动被销毁。</li><li>OnRestart(): 由停止变为可运行状态前调用。</li><li>OnCreate()&lt;-----&gt;OnDestory():完整的生命周期</li><li>OnStart()&lt;---------&gt;OnStop():可见生存周期</li><li>OnResume()&lt;-------&gt;OnPause():前台生存周期，活动总是在运行状态。 <img src="http://ww2.sinaimg.cn/mw690/006lPiqbjw1f38w1sk7onj30f50jr40c.jpg" alt="经典示意图"> 在这三种生命周期的基础上衍生出来三种执行顺序：</li><li>执行顺序:杀死进程/新建-&gt;活动 onCreate()--&gt;onStart()--&gt;OnResume()--&gt;用户交互--&gt;OnPause()--&gt;OnStop()--&gt;OnDestory()--&gt;OnCreate();</li><li>执行顺序:活动可见-&gt;返回上一个活动 OnResume()--&gt;OnPause()--&gt;OnResume();</li><li>执行顺序：活动被切换--&gt;重新切换回来成为当前活动 onStart()--&gt;OnResume()--&gt;OnPause()--&gt;onStop()--&gt;onRestart()--OnStart(); <strong>可以看出，activity执行时所操作的方法都是成对出现的，即有开始，就要有结束。</strong></li><li>执行示例1：点击A活动来到B活动，B全部遮挡住A，执行顺序为：A:OnPause()-&gt;B:OnCreate()-&gt;B:OnStart()-&gt;B:OnResume()-&gt;A:onStop();单击back键后的顺序：B:Onpause()-&gt;A:OnRestart()-&gt;A:Onstart()-&gt;A:OnResume()-&gt;B:OnStop()-&gt;B:OnDestroy().</li></ul><h4 id="常操作的几个活动时执行的顺序" tabindex="-1">常操作的几个活动时执行的顺序 <a class="header-anchor" href="#常操作的几个活动时执行的顺序" aria-label="Permalink to &quot;常操作的几个活动时执行的顺序&quot;">​</a></h4><ul><li>启动Activity:onCreate--&gt;OnStart()--&gt;OnResume()</li><li>跳转到其他Activity/home键返回到主屏幕：OnSaveInstanceState()--&gt;OnPause()--&gt;onStop();这也是home键和back键不同的地方，activity并没有被销毁。在数据重置方面，可以使用savedInstanceState来获取onSaveInstanceState()中已经保留的值。</li><li>跳转回来：OnRestart()--&gt;OnStart()--&gt;OnResume();</li><li>BACK键：OnPause()--&gt;onStop()--&gt;onDestory()如果想在按下back键后，实现home键的效果，即活动并非结束重新启动，而是保留在当前的activity，需要重写Back键的回调函数 @Override onBackPressed(){}；然后有两种方法：1.替换成Home键的效果。{Intent.CATEGORY_HOME}2.调用activity提供的方法：moveTaskToBack(true);</li><li>旋转屏幕：将会先保存数据，然后销毁当前的activity,在重新生成一个，并将其保存的数据重置回来，执行顺序如下。</li><li>OnSaveInstanceState()--&gt;Onpause()--&gt;OnStop()--&gt;OnDestory()--&gt;OnCreate()--&gt;OnStart()--&gt;OnRestoreInstanceState()--OnResume();</li></ul><h3 id="调用方法" tabindex="-1">调用方法 <a class="header-anchor" href="#调用方法" aria-label="Permalink to &quot;调用方法&quot;">​</a></h3><ul><li>activity.finish():将activity从Activity栈中移除，并调用activity的onDestory()函数。</li><li>startActivityForResult/OnActivityResult/setResult:获取返回值的调用activity方法</li><li>startActivity(intent):开启一个新的activity,将其入栈。</li><li>所有的activity均需要在Androidmanifest.xml中注册</li><li>自定义的activity类均需要继承activity类。</li></ul><blockquote><p><a href="http://www.cnblogs.com/bastard/archive/2012/04/07/2436262.html" target="_blank" rel="noreferrer">Activity启动和创建过程--只需要了解</a> <a href="http://www.cnblogs.com/JohnTsai/p/4051843.html" target="_blank" rel="noreferrer">Activity经典注释</a> <a href="http://www.cnblogs.com/jasoncc/archive/2011/07/21/2113314.html" target="_blank" rel="noreferrer">Activity生命周期2</a> <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0724/1481.html" target="_blank" rel="noreferrer">Activity之间传输数据的几种方式</a> <a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="noreferrer">Activity启动源代码</a> <a href="http://www.cnblogs.com/meizixiong/p/3170591.html" target="_blank" rel="noreferrer">Activity四种启动方式--下班了，没看</a> <a href="http://www.cnblogs.com/EX32/p/4623764.html" target="_blank" rel="noreferrer">Activity四种启动方式---同上</a></p></blockquote>',13)]))}const O=e(l,[["render",n]]);export{d as __pageData,O as default};
